#include "Arduino.h"
    
    #define LATCHPIN 6  // PLN
    #define STCP 2  
    #define CLOCKPIN 3  //SHCP
    #define Resetpin 4 // MR
    #define datapin 5  // Q
    //#define E6 6   
    #define RSTN 7  
    #define E8 8   
    #define OEN 9  
    #define SEL_1 12    

    int incoming;
    int incoming2;
    int EncoderCount;
    int msb;

    //control
    

#define segment1_start    0
#define segment1_end      1
#define segment2_start    1
#define segment2_end      3
#define segment3_start    3
#define segment3_end      5
#define segment4_start    5
#define segment4_end      7
#define segment5_start    7
#define segment5_end      9
#define segment6_start    9
#define segment6_end      11
#define segment7_start    11
#define segment7_end      13
#define segment8_start    13
#define segment8_end      15

#define PWM_HIGH          220
#define PWM_MED           127
#define PWM_LOW           35

int arr[3] = {0,0,0};

double setpoint_pos = 11;
double actual_pos = 0;
double error = 0;

int PWM_val = 127;

#define coil1             10
#define coil2             11
     
void setup() {

    pinMode(coil1, OUTPUT);
    pinMode(coil2, OUTPUT);
    analogWrite(coil1, PWM_MED);
    analogWrite(coil2, PWM_MED);

    // PINS for the ShiftRegister
    pinMode(LATCHPIN, OUTPUT); // PLN
    pinMode(STCP, OUTPUT); // STCP
    pinMode(CLOCKPIN, OUTPUT); // SHCP
    pinMode(Resetpin, OUTPUT); // MR
    pinMode(datapin, INPUT); // Q

    // PINS for the Decoder
    pinMode(RSTN, OUTPUT); // RSTN
    pinMode(E8, INPUT); // U/D
    pinMode(OEN, OUTPUT); // OEN
    pinMode(SEL_1, OUTPUT); // SEL_1


    digitalWrite(Resetpin, LOW); //Clear the register
    digitalWrite(RSTN, LOW); // Reset the counter

    Serial.begin (250000);
    Serial.print("The counter is reading up (1) or down (0)");
    
    Serial.println(E8, BIN);

    // COntrols for the Decoder 
      digitalWrite(RSTN, HIGH);  // RSTN          
      digitalWrite(OEN, LOW);   // OEN
      digitalWrite(SEL_1, HIGH); // SEL_1

      // Controls for the Shiftregister
      // set initial states while holding reset         
        digitalWrite(CLOCKPIN, LOW); 
        digitalWrite(LATCHPIN, HIGH); 
        digitalWrite(STCP, LOW);  
        // come out of reset
        
        delay(5);

        digitalWrite(Resetpin, HIGH); 
       
        delay(5);

}
 
void loop() { 
        // load data to input flip-flops
        digitalWrite(LATCHPIN, LOW);
        delay(10); 
        digitalWrite(LATCHPIN, HIGH); 
        
        // transfer data to shift register
        digitalWrite(STCP, HIGH);
        delay(10); 
        digitalWrite(STCP, LOW); 

        msb = digitalRead(datapin);
        
        incoming = shiftIn(datapin, CLOCKPIN, MSBFIRST);
        //incoming2 = shiftIn(datapin, CLOCKPIN, MSBFIRST);  
        //EncoderCount = incoming >> 1;        

        msb = msb << 8;
        incoming2 = msb + incoming;
        incoming2 = incoming2 >> 1;
        if((incoming2 >= 250) && (!digitalRead(E8))){
          incoming = 0;
        }
 
//        Serial.print("Binary: ");
//        Serial.print(incoming2, BIN);
        
        Serial.print(" Decimal: ");
        Serial.print(incoming2);

        actual_pos = (incoming2 * 0.75)/10;
        lookup(actual_pos); //check which coil to turn on
        error = setpoint_pos - actual_pos; //calculate the error

  if(error <  0) {
    if(arr[1] == 0){ // CCW
      PWM_val = PWM_LOW;
    }
    else if(arr[1] == 1) { //CW
      PWM_val = PWM_HIGH;
    }
    else PWM_val = PWM_MED;
  } 
  else if(error > 0) {
    if(arr[2] == 0){ // CCW
      PWM_val = PWM_LOW;
    }
    else if(arr[2] == 1) { //CW
      PWM_val = PWM_HIGH;
    }
    else PWM_val = PWM_MED;
  }
  else PWM_val = PWM_MED;

  if(arr[0] == 1) { // if its Coil 1
    analogWrite(coil1, PWM_val);
    analogWrite(coil2, PWM_MED);
  }
  else if(arr[0] == 2) { // if its Coil 2
    analogWrite(coil2, PWM_val);
    analogWrite(coil1, PWM_MED);
  }
  else{
    analogWrite(coil1, PWM_MED);
    analogWrite(coil2, PWM_MED);
  }

  Serial.print(" Actual: ");
  Serial.print(actual_pos);
  Serial.print(" Error: ");
  Serial.print(error);
  Serial.print(" PWM: ");
  Serial.print(PWM_val);
  Serial.print(" ");
  for(int i = 0; i < 3; i++)
  {
    Serial.print(arr[i]);
  }  
  Serial.print("\n");

}



void lookup(double rotor_pos) {
  //SEGMENT 1_________________________________________________________________
  if(rotor_pos >= segment1_start && rotor_pos < segment1_end) {
    arr[0] = 1;
    arr[1] = 1;
    arr[2] = 0;
  }
  //SEGMENT 2_________________________________________________________________
  else if(rotor_pos >= segment2_start && rotor_pos < segment2_end) {
    arr[0] = 2;
    arr[1] = 1;
    arr[2] = 0;
  }
  //SEGMENT 3_________________________________________________________________
  else if(rotor_pos >= segment3_start && rotor_pos < segment3_end) {
    arr[0] = 1;
    arr[1] = 0;
    arr[2] = 1;
  }
  //SEGMENT 4_________________________________________________________________
  else if(rotor_pos >= segment4_start && rotor_pos < segment4_end) {
    arr[0] = 2;
    arr[1] = 0;
    arr[2] = 1;
  }
  //SEGMENT 5_________________________________________________________________
  else if(rotor_pos >= segment5_start && rotor_pos < segment5_end) {
    arr[0] = 1;
    arr[1] = 1;
    arr[2] = 0;
  }
  //SEGMENT 6_________________________________________________________________
  else if(rotor_pos >= segment6_start && rotor_pos < segment6_end) {
    arr[0] = 2;
    arr[1] = 1;
    arr[2] = 0;
  }
  //SEGMENT 7_________________________________________________________________
  else if(rotor_pos >= segment7_start && rotor_pos < segment7_end) {
    arr[0] = 1;
    arr[1] = 0;
    arr[2] = 1;    
  }
  //SEGMENT 8_________________________________________________________________
  else if(rotor_pos >= segment8_start && rotor_pos < segment8_end) {
    arr[0] = 2;
    arr[1] = 0;
    arr[2] = 1;
  }
  else{
    arr[0] = 1;
    arr[1] = 0;
    arr[2] = 1;
  }
}
